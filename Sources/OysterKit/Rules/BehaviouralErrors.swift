//    Copyright (c) 2018, RED When Excited
//    All rights reserved.
//
//    Redistribution and use in source and binary forms, with or without
//    modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
//    * Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
//    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import Foundation

/**
 An error type that captures not just a current error, but the hierarchy of
 errors that caused it.
 */
public protocol CausalErrorType : Error, CustomStringConvertible, CustomDebugStringConvertible{
    /// Any errors which can be rolled up into this error
    var causedBy : [Error]? {get}
    
    /// The range of the error in the source `String`
    var range    : ClosedRange<String.Index>? {get}
    
    /// The message associated with the error
    var message  : String {get}
    
    /// The error should stop subsequent processing
    var isFatal : Bool {get}
}

/**
 Adds some core standard functionality for automatically assembling error messages
 */
public extension CausalErrorType {
    /// A textural description of the error
    var description : String {
        return message
    }
    /// A more detailed description of the error including the hierarchy of errors that built to this error
    var debugDescription : String {
        func dumpCauses(_ indent:Int = 1, causes:[Error])->String{
            var result = ""
            for cause in causes {
                if let cause = cause as? CausalErrorType {
                    result += "\(String(repeating:"\t",count:indent))- \(cause.description)\n\(dumpCauses(indent+1,causes: cause.causedBy ?? []))"
                } else {
                    result += "\(String(repeating:"\t",count:indent))- \(cause.localizedDescription)\n"
                }
            }
            return result
        }
        if let causes = causedBy, !causes.isEmpty {
            return "\(message). Caused by:\n\(dumpCauses(causes: causes))"
        } else {
            return description
        }
    }
}

/**
 A useful standard implementation of `TestErrorType` that enables the reporting of most kinds of issues
 */
public enum ProcessingError : CausalErrorType {
    /// An internal error (perhaps an exception thrown compiling a regular expression) that can be wrapped
    /// to provide a `TestError`
    case `internal`(cause:Error)
    /// An error where no specific error message has been defined
    case undefined(message:String, at: String.Index, causes:[Error])
    /// An error during scanning, with a defined message
    case scanning(message:String,position:String.Index,causes:[Error])
    /// An error during parsing, with a defined message
    case parsing(message:String,range:ClosedRange<String.Index>,causes:[Error])
    /// An error during interpretation of parsed results, with a defined message
    case interpretation(message:String,causes:[Error])
    /// A fatal error that should stop parsing and cause exit to the top
    case fatal(message:String, causes:[Error])
    
    /// `true` if `ProcessingError.fatal`
    public var isFatal: Bool{
        if case ProcessingError.fatal = self {
            return true
        }
        return false
    }
    
    /**
     Constructs a scanning or parsing error (depending on wether or not a `TokenType` is supplied) from the supplied data.
     
     - Parameter behaviour: The behaviour of the rule that encountered the error
     - Parameter annotations: Annotations on the rule that encountered the error
     - Parameter lexer: The lexical analyzer being used for scanning
     - Parameter errors: That were generated by any contained tests
    */
    public init(with behaviour:Behaviour, and annotations:RuleAnnotations, whenUsing lexer:LexicalAnalyzer, causes errors:[Error]?){
        if let error = annotations.error{
            switch behaviour.kind {
            case .skipping, .scanning:
                self = .scanning(message: error , position: lexer.index, causes: errors ?? [])
            case .structural:
                self = .parsing(message: error, range: lexer.index...lexer.index, causes: errors ?? [])
            }
        } else {
            self = .undefined(message: "Undefined error", at: lexer.index, causes: errors ?? [])
        }
    }
    
    /// The errors that caused this error, or nil if this is the root error
    public var causedBy: [Error]?{
        switch self {
        case .fatal(_, let causes):
            return causes
        case .`internal`(let cause):
            return [cause]
        case .scanning(_, _,let causes):
            return causes
        case .parsing(_, _, let causes):
            return causes
        case .interpretation(_, let causes):
            return causes
        case .undefined(_,_, let causes):
            return causes
        }
    }
    
    internal var causeRange : ClosedRange<String.Index>?{
        var lowerBound : String.Index?
        var upperBound : String.Index?
        
        for cause in causedBy ?? []{
            if let causeRange = (cause as? CausalErrorType)?.range {
                lowerBound = min(lowerBound ?? causeRange.lowerBound, causeRange.lowerBound)
                upperBound = max(upperBound ?? causeRange.upperBound, causeRange.upperBound)
            }
        }
        
        switch (lowerBound, upperBound) {
        case (let lower, nil) where lower != nil:
            return lower!...lower!
        case (nil, let upper) where upper != nil:
            return upper!...upper!
        case (let lower,let upper) where upper != nil && lower != nil:
            return lower!...upper!
        default:
            return nil
        }
    }
    
    /// The range in the source string that caused this error, or nil (for example an internal error)
    public var range: ClosedRange<String.Index>?{
        switch self {
        case .`internal`, .interpretation:
            return nil
        case .fatal:
            return causeRange
        case .scanning(_, let position, _), .undefined(_, let position, _):
            return position...position
        case .parsing(_, let range, _):
            return range
        }
    }
    
    /// A human readable version of the error message. It does not include any causes
    /// except for internal error (where the cause really is the error being reported)
    public var message : String {
        switch self {
        case .`internal`(let cause):
            if let cause = cause as? LocalizedError {
                return "Internal Error: \(cause.localizedDescription)"
            }
            return "Internal Error"
        case .undefined(let message, let position, let causes):
            if causes.isEmpty {
                return "\(message) at \(position.encodedOffset)"
            } else {
                return "\(message) error at \(position.encodedOffset) caused by "+causes.map({"\($0)"}).joined(separator: ", ")
            }
        case .scanning(let message, let position, let causes):
            if causes.isEmpty{
                return "Scanning Error: \(message) at \(position.encodedOffset)"
            } else {
                return "Scanning Error: \(message) at \(position.encodedOffset) caused by "+causes.map({"\($0)"}).joined(separator: ", ")
            }
        case .parsing(let message, let range, let causes):
            let causeText = causes.map({"\($0)"}).joined(separator: ", ")
            if range.lowerBound == range.upperBound {
                return "Parsing Error: \(message) at \(range.lowerBound.encodedOffset)"+(causeText.isEmpty ? "" : " caused by \(causeText)")
            }
            return "Parsing Error: \(message) between \(range.lowerBound.encodedOffset) and \(range.upperBound.encodedOffset)"+(causeText.isEmpty ? "" : " caused by \(causeText)")
        case .fatal(let message, let causes):
            let causeText = causes.map({"\($0)"}).joined(separator: ", ")
            return "Fatal Error: \(message)"+(causeText.isEmpty ? "" : " caused by \(causeText)")
        case .interpretation(let message, _):
            return "Interpretation Error: \(message)"
        }
    }
    
    /// A textual description of the error and its causes
    public var description: String {
        return message
    }
}

public extension CausalErrorType {
    /**
     Returns true if the supplied error includes the supplied description in its description
    
     - Parameter description: The text being searched for
     - Returns: True if it contains the message, false if not
    */
    public func hasCause(description:String)->Bool{
        if message.contains(description){
            return true
        }
        for cause in causedBy ?? [] {
            if let cause = cause as? CausalErrorType, cause.hasCause(description: description){
                return true
            } else if "\(cause)".contains(description){
                return true
            }
        }
        return false
    }
}
