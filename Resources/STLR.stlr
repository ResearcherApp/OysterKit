/************************************************************

Swift Tool for Language Recognition (STLR)

STLR can be fully described itself, and this example is
provided to both provide  a formal document capturing STLR
and to illustrate a complex use of the format.

Change log:
v0.0.0  8  Aug 2016     Initial version
v0.0.1  15 Aug 2016     Added annotations changed to remove semi-colons and use " not '
v0.0.2  16 Aug 2016     Added look ahead
v0.0.3  17 Aug 2016     Added errors to grammar
v0.0.4  18 Aug 2016     Changed the format of annotations to be more Swift like
v0.0.5  22 Aug 2016     Added support for nested multiline comments
v0.0.6  24 Aug 2016     Changed position of negation operator to better match
                        Swift and added more error information.
v0.0.7  10 Sep 2017     Added module importing
v0.1.2  7  Dec 2017     Added backslash character set
v0.1.3  28 Feb 2018     Changed plurality of character sets
v0.1.4  9  Jul 2018     Added regular expression terminals
v0.1.5  11 Jul 2018     Removed support for nested inlines, replaced whitespace rules with regular expression increasing parsing performance by over 2x

*************************************************************/

//
// Whitespace
//
@void
whitespace                              = /[:space:]+|/\*(?:.|\r?\n)*?\*/|//.*(?:\r?\n|$)/
@void
ows                                             = whitespace*

//
// Constants
//
//definition                    = "const"       ows identifier ows "=" ows literal .whitespace* whitespace

//
// Quantifiers
//
quantifier                              = "*" | "+" | "?" | "-"
negated                                 = "!"
transient                               = "-"

//
// Parsing Control
//
lookahead                               = ">>"

//
// String
//
stringQuote          = "\""
terminalBody         = /(\\.|[^"\\\n])+/
stringBody           = /(\\.|[^"\\\n])*/

string               = stringQuote stringBody @error("Missing terminating quote") stringQuote
terminalString       = stringQuote @error("Terminals must have at least one character") terminalBody @error("Missing terminating quote") stringQuote

//
// Character Sets and Ranges
//
characterSetName                = "letter" |
"uppercaseLetter" |
"lowercaseLetter" |
"alphaNumeric" |
"decimalDigit" |
"whitespaceOrNewline" |
"whitespace" |
"newline" |
"backslash"

characterSet                    = ("." @error("Unknown character set") characterSetName)

@void
rangeOperator                   = ".." @error("Expected ... in character range") "."
characterRange                  = terminalString rangeOperator @error("Range must be terminated") terminalString

//
// Types
//
number                                  = ("-" | "+")? .decimalDigit+
boolean                                 = "true" | "false"
literal                                 = string | number | boolean

//
// Annotations
//
annotation                      = "@"
@error("Expected an annotation label") label (
"("
@error("A value must be specified or the () omitted")
literal
@error("Missing ')'")
")"
)?
annotations                     = (annotation ows)+

customLabel                     = @error("Labels must start with a letter or _") (.letter | "_") ( .letter | .decimalDigit | "_" )*
definedLabel                    = "token" | "error" | "void" | "transient"
label                                   = definedLabel | customLabel

//
// Regular Expressions
//
@void regexDelimeter = "/"
@void startRegex = regexDelimeter >>!"*" >>!"/"
@void endRegex = regexDelimeter
@transient regexBody = !(regexDelimeter whitespace)+
regex = startRegex regexBody endRegex

//
// Element
//
terminal                                = characterSet | characterRange | terminalString | regex
group                                   = "(" whitespace*
expression whitespace*
@error("Expected ')'")
")"
identifier                              = /[:alpha:]\w*|_\w*/

element                                 = annotations? (lookahead | transient)? negated? ( group | terminal | identifier ) quantifier?

//
// Expressions
//
assignmentOperators             = "=" | "+=" | "|="
@void
or                                              =  whitespace* "|" whitespace*
@void
then                                    = (whitespace* "+" whitespace*) | whitespace+

choice                                  = element (or @error("Expected terminal, identifier, or group") element)+
notNewRule                              = !(annotations? identifier whitespace* assignmentOperators)
sequence                                = element (then >>notNewRule @error("Expected terminal, identifier, or group")element)+

expression                              = choice | sequence | element

//
// Rule
//
@transient
lhs                                             = whitespace* annotations? transient? identifier whitespace* assignmentOperators
rule                                    = lhs whitespace* @error("Expected expression")expression whitespace*

//
// Importing
//
moduleName                              = (.letter | "_") (.letter | "_" | .decimalDigit)*
moduleImport                    = whitespace* @token("import") "import" .whitespace+  moduleName whitespace+

//
// Grammar
//

grammar                                 = @token("mark") >>(!" "|" ") moduleImport* @error("Expected at least one rule") rule+ //NB: Mark is there to ensure there is no automatic reduction of rule into grammar if there is only one rule, this should perhaps become an annotation
